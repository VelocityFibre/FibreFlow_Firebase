import { Injectable, inject } from '@angular/core';
import {
  Firestore,
  collection,
  doc,
  setDoc,
  deleteDoc,
  query,
  where,
  collectionData,
  docData,
  serverTimestamp,
  writeBatch,
  Timestamp
} from '@angular/fire/firestore';
import { Observable, from, combineLatest, map, switchMap, of } from 'rxjs';
import { StaffFacadeService } from '../../features/staff/public-api';
import { ProjectService } from '../../features/projects/services/project.service';
import {
  StaffAssignment,
  TaskAssignment,
  ProjectStaffRequirement,
  StaffWorkload,
  StaffProjectSummary,
  DateRange,
  StaffRecommendation
} from '../../shared/interfaces/staff-project.interface';
import { StaffMember } from '../../features/staff/public-api';

@Injectable({
  providedIn: 'root'
})
export class StaffProjectBridgeService {
  private firestore = inject(Firestore);
  private staffFacade = inject(StaffFacadeService);
  private projectService = inject(ProjectService);

  // Collections
  private projectStaffCollection = (projectId: string) => 
    collection(this.firestore, `project_staff/${projectId}/assignments`);
  
  private staffProjectsCollection = (staffId: string) => 
    collection(this.firestore, `staff_projects/${staffId}/projects`);
  
  private taskAssignmentsCollection = collection(this.firestore, 'task_assignments');

  // Assign staff to project
  assignStaffToProject(assignment: Omit<StaffAssignment, 'id'>): Observable<void> {
    const batch = writeBatch(this.firestore);
    const assignmentId = doc(collection(this.firestore, 'temp')).id;

    // Add to project's staff collection
    const projectStaffDoc = doc(this.projectStaffCollection(assignment.projectId), assignment.staffId);
    batch.set(projectStaffDoc, {
      ...assignment,
      id: assignmentId,
      assignedDate: serverTimestamp()
    });

    // Add to staff's projects collection (denormalized for performance)
    const staffProjectDoc = doc(this.staffProjectsCollection(assignment.staffId), assignment.projectId);
    batch.set(staffProjectDoc, {
      ...assignment,
      id: assignmentId,
      assignedDate: serverTimestamp()
    });

    // Update staff task count
    const staffDoc = doc(this.firestore, 'staff', assignment.staffId);
    batch.update(staffDoc, {
      'activity.totalProjectsWorked': increment(1),
      updatedAt: serverTimestamp()
    });

    return from(batch.commit());
  }

  // Remove staff from project
  removeStaffFromProject(projectId: string, staffId: string, reason?: string): Observable<void> {
    const batch = writeBatch(this.firestore);

    // Update assignment status
    const projectStaffDoc = doc(this.projectStaffCollection(projectId), staffId);
    batch.update(projectStaffDoc, {
      status: 'removed',
      removalDate: serverTimestamp(),
      removalReason: reason
    });

    const staffProjectDoc = doc(this.staffProjectsCollection(staffId), projectId);
    batch.update(staffProjectDoc, {
      status: 'removed',
      removalDate: serverTimestamp(),
      removalReason: reason
    });

    return from(batch.commit());
  }

  // Get all staff assigned to a project
  getProjectStaff(projectId: string): Observable<StaffAssignment[]> {
    const q = query(
      this.projectStaffCollection(projectId),
      where('status', '==', 'active')
    );
    
    return collectionData(q, { idField: 'id' }) as Observable<StaffAssignment[]>;
  }

  // Get all projects for a staff member
  getStaffProjects(staffId: string): Observable<StaffAssignment[]> {
    const q = query(
      this.staffProjectsCollection(staffId),
      where('status', 'in', ['active', 'completed'])
    );
    
    return collectionData(q, { idField: 'id' }) as Observable<StaffAssignment[]>;
  }

  // Check staff availability for project
  checkStaffAvailability(
    staffId: string, 
    projectId: string, 
    dateRange: DateRange
  ): Observable<boolean> {
    return this.staffFacade.getStaffById(staffId).pipe(
      switchMap(staff => {
        if (!staff || !staff.isActive) return of(false);
        if (staff.availability.status === 'vacation' || staff.availability.status === 'offline') {
          return of(false);
        }
        
        // Check if staff has capacity
        const hasCapacity = staff.availability.currentTaskCount < staff.availability.maxConcurrentTasks;
        
        // Check for conflicts with vacation dates
        if (staff.availability.vacationDates) {
          const hasConflict = staff.availability.vacationDates.some(vacation => {
            const vacationStart = vacation.startDate.getTime();
            const vacationEnd = vacation.endDate.getTime();
            const rangeStart = dateRange.start.getTime();
            const rangeEnd = dateRange.end.getTime();
            
            return (rangeStart <= vacationEnd && rangeEnd >= vacationStart);
          });
          
          if (hasConflict) return of(false);
        }
        
        return of(hasCapacity);
      })
    );
  }

  // Get recommended staff for project based on skills/availability
  getRecommendedStaff(requirement: ProjectStaffRequirement): Observable<StaffRecommendation[]> {
    return this.staffFacade.getAvailableStaff(requirement.requiredSkills).pipe(
      map(staffList => {
        const recommendations: StaffRecommendation[] = staffList.map(staff => {
          const matchingSkills = staff.skills?.filter(skill => 
            requirement.requiredSkills.includes(skill)
          ) || [];
          
          const missingSkills = requirement.requiredSkills.filter(skill =>
            !staff.skills?.includes(skill)
          );
          
          // Calculate match score
          const skillScore = (matchingSkills.length / requirement.requiredSkills.length) * 50;
          const availabilityScore = staff.availability.status === 'available' ? 30 : 15;
          const workloadScore = (1 - (staff.availability.currentTaskCount / staff.availability.maxConcurrentTasks)) * 20;
          
          const matchScore = Math.round(skillScore + availabilityScore + workloadScore);
          
          // Determine recommendation level
          let recommendation: 'highly-recommended' | 'recommended' | 'available';
          if (matchScore >= 80 && matchingSkills.length === requirement.requiredSkills.length) {
            recommendation = 'highly-recommended';
          } else if (matchScore >= 60) {
            recommendation = 'recommended';
          } else {
            recommendation = 'available';
          }
          
          // Build recommendation reasons
          const reasons: string[] = [];
          if (matchingSkills.length === requirement.requiredSkills.length) {
            reasons.push('Has all required skills');
          }
          if (staff.availability.status === 'available') {
            reasons.push('Currently available');
          }
          if (staff.availability.currentTaskCount < staff.availability.maxConcurrentTasks / 2) {
            reasons.push('Low workload');
          }
          
          return {
            staff: {
              id: staff.id,
              name: staff.name,
              primaryGroup: staff.primaryGroup,
              photoUrl: staff.photoUrl
            },
            matchScore,
            availability: {
              status: staff.availability.status,
              availableHours: (staff.availability.maxConcurrentTasks - staff.availability.currentTaskCount) * 8,
              currentWorkload: (staff.availability.currentTaskCount / staff.availability.maxConcurrentTasks) * 100
            },
            matchingSkills,
            missingSkills,
            recommendation,
            reasons
          };
        });
        
        // Sort by match score
        return recommendations.sort((a, b) => b.matchScore - a.matchScore);
      })
    );
  }

  // Assign task to staff member
  assignTask(assignment: Omit<TaskAssignment, 'id'>): Observable<void> {
    const taskDoc = doc(this.taskAssignmentsCollection);
    
    return from(setDoc(taskDoc, {
      ...assignment,
      assignedDate: serverTimestamp()
    })).pipe(
      switchMap(() => {
        // Update staff task count
        // Note: incrementTaskCount is internal - we'll handle this via events
        return of(void 0);
      })
    );
  }

  // Get staff tasks
  getStaffTasks(staffId: string, status?: string[]): Observable<TaskAssignment[]> {
    let q = query(
      this.taskAssignmentsCollection,
      where('staffId', '==', staffId)
    );
    
    if (status) {
      q = query(q, where('status', 'in', status));
    }
    
    return collectionData(q, { idField: 'id' }) as Observable<TaskAssignment[]>;
  }

  // Update task status
  updateTaskStatus(taskId: string, status: TaskAssignment['status'], staffId: string): Observable<void> {
    const taskDoc = doc(this.taskAssignmentsCollection, taskId);
    const updates: any = {
      status,
      updatedAt: serverTimestamp()
    };
    
    if (status === 'completed') {
      updates.completedDate = serverTimestamp();
    }
    
    return from(updateDoc(taskDoc, updates)).pipe(
      switchMap(() => {
        // Update staff metrics
        if (status === 'completed') {
          return this.updateStaffMetrics(staffId, { tasksCompleted: 1 });
        }
        return of(void 0);
      })
    );
  }

  // Get staff workload
  getStaffWorkload(staffId: string): Observable<StaffWorkload> {
    return combineLatest([
      this.getStaffTasks(staffId),
      this.staffFacade.getStaffById(staffId)
    ]).pipe(
      map(([tasks, staff]) => {
        if (!staff) throw new Error('Staff not found');
        
        const tasksByStatus = tasks.reduce((acc, task) => {
          acc[task.status] = (acc[task.status] || 0) + 1;
          return acc;
        }, {} as Record<string, number>);
        
        const totalEstimatedHours = tasks.reduce((sum, task) => 
          sum + (task.estimatedHours || 0), 0
        );
        
        const totalActualHours = tasks.reduce((sum, task) => 
          sum + (task.actualHours || 0), 0
        );
        
        const availableHours = staff.availability.maxConcurrentTasks * 8 - totalEstimatedHours;
        const utilizationPercentage = (totalEstimatedHours / (staff.availability.maxConcurrentTasks * 8)) * 100;
        
        return {
          staffId,
          totalTasks: tasks.length,
          pendingTasks: tasksByStatus['pending'] || 0,
          inProgressTasks: tasksByStatus['started'] || 0,
          completedTasks: tasksByStatus['completed'] || 0,
          flaggedTasks: tasksByStatus['flagged'] || 0,
          totalEstimatedHours,
          totalActualHours,
          utilizationPercentage: Math.round(utilizationPercentage),
          availableHours: Math.max(0, availableHours)
        };
      })
    );
  }

  // Get staff project summary
  getStaffProjectSummary(staffId: string): Observable<StaffProjectSummary> {
    return this.getStaffProjects(staffId).pipe(
      map(projects => {
        const activeProjects = projects.filter(p => p.status === 'active').length;
        const completedProjects = projects.filter(p => p.status === 'completed').length;
        const totalHoursWorked = projects.reduce((sum, p) => sum + (p.actualHours || 0), 0);
        
        const projectList = projects.map(p => ({
          projectId: p.projectId,
          projectName: p.projectName || 'Unknown Project',
          role: p.role,
          status: p.status,
          hoursWorked: p.actualHours || 0
        }));
        
        return {
          staffId,
          activeProjects,
          completedProjects,
          totalProjectsWorked: projects.length,
          totalHoursWorked,
          currentWorkload: (activeProjects / 5) * 100, // Assuming 5 projects is 100% workload
          projectList
        };
      })
    );
  }

  // Private helper to update staff metrics
  private updateStaffMetrics(staffId: string, metrics: Partial<any>): Observable<void> {
    const updates: any = {
      updatedAt: serverTimestamp()
    };
    
    if (metrics.tasksCompleted) {
      updates['activity.tasksCompleted'] = increment(metrics.tasksCompleted);
    }
    
    // Note: updateStaff is internal - we'll handle this via events
    return of(void 0);
  }
}

// Helper function for Firestore increment
function increment(n: number): any {
  // This would use FieldValue.increment(n) in actual implementation
  return { increment: n };
}

// Helper function for Firestore updateDoc
function updateDoc(docRef: any, data: any): Promise<void> {
  // This would use the actual updateDoc from Firestore
  return Promise.resolve();
}